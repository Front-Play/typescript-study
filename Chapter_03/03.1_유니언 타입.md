# 챕터3. 유니언과 리터럴

러닝 타입스크립트 63p

<br/>

## 핵심

타입스크립트가 값을 바탕으로 어떻게 추론을 할까 ?

- 유니언(union): 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장
- 내로잉(narrowing): 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것

타입스크립트에서는 '코드 정보에 입각한 추론'을 해낼 수 있는데 그 때 쓰이는 개념이 유니언과 내로잉이다

<br/>
<br/>

## 03.1 유니언 타입

```
let mathematician = Math.random() > 0.5 ? undefined : 'Mark Goldberg
```

🙄(typescript의 추론) `mathematican은 string | undefined 타입이군`

<br/>

- mathematican은 string ? - x
- mathematican은 undefined ? - x
- mathematican은 undefined || string - o

<br/>

이렇게 '이거 혹은 저거'와 같은 타입을 **유니언**이라고 합니다.

따라서 값이 정확히 어떤 타입인지는 모르지만, 두 개 이상의 옵션 중 하나라는 것을 알고 있는 경우에 유니언 타입을 사용할 수 있습니다.

<br/>
<br/>

### 03.1.1 유니언 타입 선언

🤔 `변수에 초기값이 있으면 유니언 타입이 필요 없나?`- x

변수에 초기값이 있더라도 잠재적으로 초짓값이 아닌 다른 타입(ex: string)이 될 수 있으면 유니언 타입을 사용하는 것이 좋습니다.

### 03.1.2 유니언 속성

> 값이 유니언 타입일 때 타입스크립트는 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있습니다. 유니언 외의 타입에 접근하려고 하면 타입 검사 오류가 발생합니다.

ex

```
const a = Math.random() > 0.5 ? '숫자' : 1
```

일 때, 두 개의 타입에 모두 존재하는 toString()을 사용할 수 있지만 toUpperCase()나 toFixed()는 사용할 수 없습니다.
만약 toUpperCase()를 사용했는데 `a = 1`이라면? 당연히 오류가 발생합니다.

<br/>

따라서 이렇게 속성에 대한 접근을 제한하는 것은 안전 조치입니다.

<br/>

🙄 `음, 확실하지 않아. 이 속성을 시도하는 것은 안전하지 않아`

<br/>

🤔 `그래도 사용하고 싶은데..`

<br/>

유니언 타입으로 정의된 타입 중 하나의 타입으로 된 값의 속성을 사용하기 위해서는 `값이 구체적인 타입 중 하나`라는 것을 타입스크립트에 알려야 합니다. 이 것을 **내로잉**이라고 부릅니다
